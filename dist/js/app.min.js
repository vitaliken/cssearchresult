/*! For license information please see app.min.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={"./src/js/app.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/functions.js */ "./src/js/modules/functions.js");\n/* harmony import */ var _modules_slider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/slider.js */ "./src/js/modules/slider.js");\n/* harmony import */ var _modules_header_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/header.js */ "./src/js/modules/header.js");\n\n\n\n\n_modules_functions_js__WEBPACK_IMPORTED_MODULE_0__.isWebp();\n\n\n//# sourceURL=webpack://customerstore/./src/js/app.js?')},"./src/js/modules/functions.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isWebp: () => (/* binding */ isWebp)\n/* harmony export */ });\nfunction isWebp() {\n    function testWebP(callback) {\n        var webP = new Image();\n        webP.onload = webP.onerror = function () {\n            callback(webP.height == 2);\n        };\n        webP.src =\n            "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA";\n    }\n\n    testWebP(function (support) {\n        if (support == true) {\n            document.querySelector("body").classList.add("webp");\n        } else {\n            document.querySelector("body").classList.add("no-webp");\n        }\n    });\n}\n\n\n//# sourceURL=webpack://customerstore/./src/js/modules/functions.js?')},"./src/js/modules/header.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\ndocument.addEventListener("DOMContentLoaded", function () {\n    var mobileMenuButton = document.getElementById("mobile-menu-btn");\n    var mobileCloseMenuButton = document.getElementById("menu-close");\n    var mobileMenu = document.getElementById("mobile-menu");\n\n    mobileMenuButton.addEventListener("click", function () {\n        mobileMenu.classList.toggle("show");\n    });\n\n    mobileCloseMenuButton.addEventListener("click", function () {\n        mobileMenu.classList.toggle("show");\n    });\n});\n\n\n//# sourceURL=webpack://customerstore/./src/js/modules/header.js?')},"./src/js/modules/slider.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\nconst slider = (function () {\n    //const\n    const slider = document.getElementById("slider"); // основная обертка\n    // console.log(slider);\n    const sliderContent = document.querySelector(".slider-content"); // обертка для контейнера слайдов и контролов\n    // console.log(sliderContent);\n    const sliderWrapper = document.querySelector(".slider-content-wrapper"); // контейнер для слайдов\n    const elements = document.querySelectorAll(".slider-content__item"); // обертка для слайда\n    const sliderContentControls = createHTMLElement(\n        "div",\n        "slider-content__controls"\n    ); // блок контролов внутри sliderContent\n    let dotsWrapper = null; // Обертка dots\n    let prevButton = null; // Кнопки\n    let nextButton = null;\n    let autoButton = null;\n    let leftArrow = null; // Стрелки\n    let rightArrow = null;\n    let intervalId = null; //идентификатор setInterval\n\n    if (slider && sliderContent && sliderWrapper && elements) {\n        // Добавляем обработчики событий для мыши\n        sliderContent.addEventListener("mousedown", handleMouseDown);\n        sliderContent.addEventListener("mouseup", handleMouseUp);\n        sliderContent.addEventListener("mousemove", handleMouseMove);\n\n        // Добавляем обработчики событий для сенсорных устройств\n        sliderContent.addEventListener("touchstart", handleTouchStart);\n        sliderContent.addEventListener("touchend", handleTouchEnd);\n        sliderContent.addEventListener("touchmove", handleTouchMove);\n    }\n    // Объявляем переменные для отслеживания координат\n    let isDragging = false;\n    let startX;\n    let endX;\n\n    // Обработчики событий для мыши\n    function handleMouseDown(event) {\n        isDragging = true;\n        startX = event.clientX;\n    }\n\n    function handleMouseUp(event) {\n        isDragging = false;\n        endX = event.clientX;\n        handleSwipe();\n    }\n\n    function handleMouseMove(event) {\n        if (isDragging) {\n            endX = event.clientX;\n        }\n    }\n\n    // Обработчики событий для сенсорных устройств\n    function handleTouchStart(event) {\n        isDragging = true;\n        startX = event.touches[0].clientX;\n    }\n\n    function handleTouchEnd(event) {\n        isDragging = false;\n        endX = event.changedTouches[0].clientX;\n        handleSwipe();\n    }\n\n    function handleTouchMove(event) {\n        if (isDragging) {\n            endX = event.touches[0].clientX;\n        }\n    }\n\n    // Обработка свайпа\n    function handleSwipe() {\n        const delta = startX - endX;\n        if (Math.abs(delta) > 50) {\n            // Измените 50 на значение, которое считаете подходящим для обнаружения свайпа\n            if (delta > 0) {\n                // Свайп влево\n                updateItemsInfo(\n                    itemsInfo.position.current === itemsInfo.position.max\n                        ? itemsInfo.position.min\n                        : itemsInfo.position.current + 1\n                );\n            } else {\n                // Свайп вправо\n                updateItemsInfo(\n                    itemsInfo.position.current === itemsInfo.position.min\n                        ? itemsInfo.position.max\n                        : itemsInfo.position.current - 1\n                );\n            }\n            _slideItem(true);\n        }\n    }\n\n    // data\n    const itemsInfo = {\n        offset: 0, // смещение контейнера со слайдами относительно начальной точки (первый слайд)\n        position: {\n            current: 0, // номер текущего слайда\n            min: 0, // первый слайд\n            max: elements.length - 1, // последний слайд\n        },\n        intervalSpeed: 2000, // Скорость смены слайдов в авторежиме\n\n        update: function (value) {\n            this.position.current = value;\n            this.offset = -value;\n        },\n        reset: function () {\n            this.position.current = 0;\n            this.offset = 0;\n        },\n    };\n\n    const controlsInfo = {\n        buttonsEnabled: false,\n        dotsEnabled: false,\n        prevButtonDisabled: true,\n        nextButtonDisabled: false,\n    };\n\n    // Инициализация слайдера\n    function init(props) {\n        // let {buttonsEnabled, dotsEnabled} = controlsInfo;\n        let { intervalSpeed, position, offset } = itemsInfo;\n\n        // Проверка наличия элементов разметки\n        if (slider && sliderContent && sliderWrapper && elements) {\n            // Проверка входных параметров\n            if (props && props.intervalSpeed) {\n                intervalSpeed = props.intervalSpeed;\n            }\n            if (props && props.currentItem) {\n                if (\n                    parseInt(props.currentItem) >= position.min &&\n                    parseInt(props.currentItem) <= position.max\n                ) {\n                    position.current = props.currentItem;\n                    offset = -props.currentItem;\n                }\n            }\n            if (props && props.buttons) {\n                controlsInfo.buttonsEnabled = true;\n            }\n            if (props && props.dots) {\n                controlsInfo.dotsEnabled = true;\n            }\n\n            _updateControlsInfo();\n            _createControls(\n                controlsInfo.dotsEnabled,\n                controlsInfo.buttonsEnabled\n            );\n            _render();\n        } else {\n            console.log(\n                "Разметка слайдера задана неверно. Проверьте наличие всех необходимых классов \'slider/slider-content/slider-wrapper/slider-content__item\'"\n            );\n        }\n    }\n\n    // Обновить свойства контролов\n    function _updateControlsInfo() {\n        const { current, min, max } = itemsInfo.position;\n        controlsInfo.prevButtonDisabled = current > min ? false : true;\n        controlsInfo.nextButtonDisabled = current < max ? false : true;\n    }\n\n    // Создание элементов разметки\n    function _createControls(dots = false, buttons = false) {\n        //Обертка для контролов\n        sliderContent.append(sliderContentControls);\n\n        // Контролы\n        createArrows();\n        buttons ? createButtons() : null;\n        dots ? createDots() : null;\n\n        // Arrows function\n        function createArrows() {\n            const dValueLeftArrow =\n                "M31.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L127.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L201.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34z";\n            const dValueRightArrow =\n                "M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z";\n            const leftArrowSVG = createSVG(dValueLeftArrow);\n            const rightArrowSVG = createSVG(dValueRightArrow);\n\n            leftArrow = createHTMLElement("div", "prev-arrow");\n            leftArrow.append(leftArrowSVG);\n            leftArrow.addEventListener("click", () =>\n                updateItemsInfo(itemsInfo.position.current - 1)\n            );\n\n            rightArrow = createHTMLElement("div", "next-arrow");\n            rightArrow.append(rightArrowSVG);\n            rightArrow.addEventListener("click", () =>\n                updateItemsInfo(itemsInfo.position.current + 1)\n            );\n\n            sliderContentControls.append(leftArrow, rightArrow);\n\n            // SVG function\n            function createSVG(dValue, color = "currentColor") {\n                const svg = document.createElementNS(\n                    "http://www.w3.org/2000/svg",\n                    "svg"\n                );\n                svg.setAttribute("viewBox", "0 0 256 512");\n                const path = document.createElementNS(\n                    "http://www.w3.org/2000/svg",\n                    "path"\n                );\n                path.setAttribute("fill", color);\n                path.setAttribute("d", dValue);\n                svg.appendChild(path);\n                return svg;\n            }\n        }\n\n        // Dots function\n        function createDots() {\n            dotsWrapper = createHTMLElement("div", "dots");\n            for (let i = 0; i < itemsInfo.position.max + 1; i++) {\n                const dot = document.createElement("div");\n                dot.className = "dot";\n                dot.addEventListener("click", function () {\n                    updateItemsInfo(i);\n                });\n                dotsWrapper.append(dot);\n            }\n            sliderContentControls.append(dotsWrapper);\n        }\n\n        // Buttons function\n        function createButtons() {\n            const controlsWrapper = createHTMLElement("div", "slider-controls");\n            prevButton = createHTMLElement("button", "prev-control", "Prev");\n            prevButton.addEventListener("click", () =>\n                updateItemsInfo(itemsInfo.position.current - 1)\n            );\n\n            autoButton = createHTMLElement("button", "auto-control", "Auto");\n            autoButton.addEventListener("click", () => {\n                intervalId = setInterval(function () {\n                    if (itemsInfo.position.current < itemsInfo.position.max) {\n                        itemsInfo.update(itemsInfo.position.current + 1);\n                    } else {\n                        itemsInfo.reset();\n                    }\n                    _slideItem();\n                }, itemsInfo.intervalSpeed);\n            });\n\n            nextButton = createHTMLElement("button", "next-control", "Next");\n            nextButton.addEventListener("click", () =>\n                updateItemsInfo(itemsInfo.position.current + 1)\n            );\n\n            controlsWrapper.append(prevButton, autoButton, nextButton);\n            slider.append(controlsWrapper);\n        }\n    }\n\n    // Задать класс для контролов (buttons, arrows)\n    function setClass(options) {\n        if (options) {\n            options.forEach(({ element, className, disabled }) => {\n                if (element) {\n                    disabled\n                        ? element.classList.add(className)\n                        : element.classList.remove(className);\n                } else {\n                    console.log(\n                        "Error: function setClass(): element = ",\n                        element\n                    );\n                }\n            });\n        }\n    }\n\n    // Обновить значения слайдера\n    function updateItemsInfo(value) {\n        itemsInfo.update(value);\n        _slideItem(true);\n    }\n\n    // Отобразить элементы\n    function _render() {\n        const { prevButtonDisabled, nextButtonDisabled } = controlsInfo;\n        let controlsArray = [\n            {\n                element: leftArrow,\n                className: "d-none",\n                disabled: prevButtonDisabled,\n            },\n            {\n                element: rightArrow,\n                className: "d-none",\n                disabled: nextButtonDisabled,\n            },\n        ];\n        if (controlsInfo.buttonsEnabled) {\n            controlsArray = [\n                ...controlsArray,\n                {\n                    element: prevButton,\n                    className: "disabled",\n                    disabled: prevButtonDisabled,\n                },\n                {\n                    element: nextButton,\n                    className: "disabled",\n                    disabled: nextButtonDisabled,\n                },\n            ];\n        }\n\n        // Отображаем/скрываем контроллы\n        setClass(controlsArray);\n\n        // Передвигаем слайдер\n        sliderWrapper.style.transform = `translateX(${\n            itemsInfo.offset * 100\n        }%)`;\n\n        // Задаем активный элемент для точек (dot)\n        if (controlsInfo.dotsEnabled) {\n            if (document.querySelector(".dot--active")) {\n                document\n                    .querySelector(".dot--active")\n                    .classList.remove("dot--active");\n            }\n            dotsWrapper.children[itemsInfo.position.current].classList.add(\n                "dot--active"\n            );\n        }\n    }\n\n    function _slideItem(autoMode = false) {\n        if (autoMode && intervalId) {\n            clearInterval(intervalId);\n        }\n        _updateControlsInfo();\n        _render();\n\n        // Добавьте следующую строку для сброса флага isDragging после завершения анимации\n        setTimeout(() => (isDragging = false), 500); // Измените 500 на длительность вашей анимации в миллисекундах\n    }\n\n    // Создать HTML разметку для элемента\n    function createHTMLElement(tagName = "div", className, innerHTML) {\n        const element = document.createElement(tagName);\n        className ? (element.className = className) : null;\n        innerHTML ? (element.innerHTML = innerHTML) : null;\n        return element;\n    }\n\n    // Доступные методы\n    return { init };\n})();\n\nslider.init({\n    intervalSpeed: 2000,\n    currentItem: 0,\n    buttons: false,\n    dots: true,\n});\n\n\n//# sourceURL=webpack://customerstore/./src/js/modules/slider.js?')}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](t,t.exports,__webpack_require__),t.exports}__webpack_require__.d=(n,e)=>{for(var t in e)__webpack_require__.o(e,t)&&!__webpack_require__.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},__webpack_require__.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/js/app.js")})();